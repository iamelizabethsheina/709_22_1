## Создать таблицы и задать связи, заполнить данными для следующих примеров:

### 1. Курьеры и заказы:
- курьер может иметь несколько заказов
- заказ может принадлежать только одному курьеру
- курьер - имя, фамилия, телефон
- заказ - адреса, дата, статус
- drop table if exists deliever, order_ cascade;
create table deliever
(
 id int primary key generated by default as identity,
 name TEXT,
 surname TEXT,
 phone TEXT
);

insert into deliever (name, surname, phone)
values
 ('Liza', 'Sheina', '81984060799'),
 ('Nikita', 'Ponomarenko', '+79893026477'),
 ('Olya', 'Nikolaevna', '+3894050492');

create table order_
(
 id int primary key generated by default as identity,
 id_deliever int references deliever,
 addres TEXT,
 order_date date,
 status TEXT
);

insert into order_ (id_deliever, addres, order_date, status)
values
 (1, 'VOSKRESENSKAYA', '2023/2/12', 'в пути'),
 (1, 'VOSKRESENSKAYA', '2034/2/20', 'не доставлено'),
 (2, 'ARBAT', '2015/11/6', 'отменено');
 

select
  deliever.id,
  deliever.name,
  deliever.surname,
  deliever.phone,
  coalesce(jsonb_agg(json_build_object(
 'id', order_.id, 'addres', order_.addres, 'date', order_.order_date, 'status', order_.status))
 filter (where order_.id is not null), '[]') as order_
from deliever
left join order_
 on order_.id_deliever = deliever.id
group by deliever.id
order by deliever.id asc;


### 2. Обращения и комментарии:
- обращение может иметь несколько комментариев
- комментарий может принадлежать только одному обращению
- обращение - номер, дата, статус
- комментарий - текст, дата публикации
- drop table if exists appeal, сomments cascade;
create table appeal
(
 id int primary key generated by default as identity,
 number int,
 appeal_date date,
 status TEXT
);

insert into appeal (number, appeal_date, status)
values
 (777, '2022/2/1', 'Одобрено'),
 (666, '2023/10/2', 'Одобрено'),
 (123, '2022/4/23', 'Отклонено');

create table сomments
(
 id int primary key generated by default as identity,
 id_appeal int references appeal,
 comments_text text,
 publication_date date
);

insert into сomments (id_appeal, comments_text, publication_date)
values
 (1, 'Отличное решение', '2034/1/2'),
 (1, 'Отличное решение', '2044/2/2'),
 (2, 'Ваше обращение одобрено', '2023/4/14');
 

select
  appeal.id,
  appeal.number,
  appeal.appeal_date,
  appeal.status,
  coalesce(jsonb_agg(json_build_object(
 'id', сomments.id, 'text', сomments.comments_text, 'date', сomments.publication_date))
 filter (where сomments.id is not null), '[]') as сomments
from appeal
left join сomments
 on сomments.id_appeal = appeal.id
group by appeal.id
order by appeal.id asc;

### 3. Покупатели и заказы:
 - покупатель может иметь несколько заказов
 - заказ принадлежит только одному покупателю
 - покупатель - имя, фамилия, телефон
 - заказ - дата, сумма
 - drop table if exists buyer, order_ cascade;
create table buyer
(
 id int primary key generated by default as identity,
 first_name TEXT,
 last_name TEXT,
 phone TEXT
);

insert into buyer (first_name, last_name, phone)
values
 ('Артем', 'Кривенко', '86529874562'),
 ('Никита', 'Носков', '89284575632'),
 ('Лиза', 'Шеина', '89457812453');

create table order_
(
 id int primary key generated by default as identity,
 id_buyer int references buyer,
 o_date date,
       summ FLOAT
);

insert into order_ (id_buyer, o_date, summ)
values
 (1, '2024/1/2', 45.3),
 (1, '2024/2/2', 645.8),
 (2, '2023/8/14', 242.4);
 

select
  buyer.id,
  buyer.first_name,
  buyer.last_name,
  buyer.phone,
  coalesce(jsonb_agg(json_build_object(
 'id', order_.id, 'date', order_.o_date, 'sum', order_.summ))
 filter (where order_.id is not null), '[]') as order_
from buyer
left join order_
 on order_.id_buyer = buyer.id
group by buyer.id
order by buyer.id asc;

## Для каждого примера сделать вывод связанных сущностей (за один запрос)
- зависимая сущность должна быть представлена в виде массива объектов
- учесть случай когда на главную таблицу может не быть ссылок в строках зависимой таблицы
- если на строки из главной таблицы нет ссылок из зависимой таблицы, эти строки всё равно должны выводиться
- на одну из строк главной таблицы должно быть хотя бы 2 ссылки из зависимой таблицы
