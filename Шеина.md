## Создать таблицы и задать связи, заполнить данными для следующих примеров:

### 1. Курсы и студенты
- курсы могут проходить несколько студентов
- студент может проходить нескольких курсах
- курс - название, описание
- студент - имя, фамилия, год поступления

### 2. Книги и авторы
- у книги может быть несколько авторов
- автор может написать несколько книг
- книга - название, жанр, год издания
- автор - имя, фамилия, год рождения

### 3. Задачи и учащиеся:
- учащийся может решить много задач
- задача может быть решена многими учащимися
- задача - название, описание, сложность
- учащийся - никнейм, дата регистрации, рейтинг

## Для каждого примера сделать вывод связанных сущностей - оба возможных варианта (например для сущностей актеров/фильмы нужно 1: для каждого актера вывести массив их фильмов, 2: для каждого фильма вывести массив их актеров)
- в качестве id нужно использовать uuid
- связанная сущность должна быть представлена в виде массива объектов
- учесть случай когда на строки в левой таблице может не быть ссылок
- --1
create extension if not exists "uuid-ossp";
drop table if exists course, student, course_to_student cascade;

create table course
(
  id uuid primary key default uuid_generate_v4(),
  title text,
  description text
);

create table student
(
  id uuid primary key default uuid_generate_v4(),
  first_name text,
  last_name text,
  year_s date  
);

create table course_to_student
(
  course_id uuid references course,
  student_id uuid references student,
  primary key(course_id, student_id)
);

insert into course(title, description)
values('programming', 'cool'),
    ('matematica', 'cool'),
    ('cxemptexnica', '???');
  
insert into student(first_name, last_name, year_s)
values ('nastik', 'zorina', '2022-08-08'),
    ('alenka', 'nikitenko', '2022-08-09'),
    ('liza', 'sheina', '2022-07-07');
  
insert into course_to_student(course_id, student_id)
values ((select id from course where title = 'programming'),
    (select id from student where first_name = 'nastik')),
  ((select id from course where title = 'programming'),
    (select id from student where first_name = 'alenka')),
  ((select id from course where title = 'programming'),
    (select id from student where first_name = 'liza')),
  ((select id from course where title = 'matematica'),
    (select id from student where first_name = 'nastik')),
  ((select id from course where title = 'matematica'),
    (select id from student where first_name = 'alenka'));

select
  c.id,
  c.title,
  c.description,
  coalesce(jsonb_agg(jsonb_build_object(
  'id', s.id, 'first_name', s.first_name, 'last_name', s.last_name,
  'year_s', s.year_s))
  filter (where s.id is not null), '[]') as student
  
from course c
left join course_to_student cs on c.id = cs.course_id
left join student s on s.id = cs.student_id
group by c.id;


select
  s.id,
  s.first_name,
  s.last_name,
  s.year_s,
  coalesce(jsonb_agg(jsonb_build_object(
  'id', c.id, 'title', c.title, 'description', c.description))
  filter (where c.id is not null), '[]') as course
  
from student s
left join course_to_student cs on s.id = cs.student_id
left join course c on c.id = cs.course_id
group by s.id;
--2
create extension if not exists "uuid-ossp";

drop table if exists authors, books, author_to_book cascade;

create table authors
(
    id uuid primary key default uuid_generate_v4(),
    at_first_name text,
    at_last_name text,
    at_date date
);

create table books
(
    id uuid primary key default uuid_generate_v4(),
    bk_name text,
    bk_genre text,
    bk_date date
);

create table author_to_book
(
    author_id uuid references authors,
    book_id  uuid references books,
    primary key (author_id, book_id)
);

insert into authors(at_first_name, at_last_name, at_date)
values ('Лиза', 'Шеина', '2006-05-19'),
       ('Антон', 'Лоб', '1900-05-19'),
       ('Артемус', 'Григорянус', '1995-05-05'),
       ('Влад', 'Аргун', '1987-01-23'),
       ('Михаил', 'Носков', '1986-11-20');


insert into books(bk_name, bk_genre, bk_date)
VALUES ('Metro 2033', 'Melodrama', '2005-08-23'),
       ('Metro 2034', 'Melodrama2', '2007-04-20'),
       ('Metro 2035', 'Melodrama3', '2009-04-20'),
       ('Metro 2036', 'Melodrama4', '2001-04-12');

insert into author_to_book(author_id, book_id)
values
    ((select id from authors where at_last_name = 'Шеина'),
     (select id from books where bk_name = 'Metro 2033')),
    ((select id from authors where at_last_name = 'Шеина'),
     (select id from books where bk_name = 'Metro 2034')),
    ((select id from authors where at_last_name = 'Лоб'),
     (select id from books where bk_name = 'Metro 2033')),
    ((select id from authors where at_last_name = 'Лоб'),
     (select id from books where bk_name = 'Metro 2034')),
    ((select id from authors where at_last_name = 'Носков'),
     (select id from books where bk_name = 'Metro 2035')),
    ((select id from authors where at_last_name = 'Григорянус'),
     (select id from books where bk_name = 'Metro 2036')),
    ((select id from authors where at_last_name = 'Аргун'),
     (select id from books where bk_name = 'Metro 2035')),
    ((select id from authors where at_last_name = 'Носков'),
     (select id from books where bk_name = 'Metro 2036'));


select
  at.id,
  at.at_first_name,
  at.at_last_name,
  at.at_date,
  coalesce(jsonb_agg(jsonb_build_object(
    'id', bk.id, 'name', bk.bk_name, 'genre', bk.bk_genre, 'date', bk.bk_date))
      filter (where bk.id is not null), '[]') as books
from authors at
left join author_to_book ba on at.id = ba.author_id
left join books bk on bk.id = ba.book_id
group by at.id;


select
  bk.id,
  bk.bk_name,
  bk.bk_genre,
  bk.bk_date,
  coalesce(json_agg(json_build_object(
    'id', at.id, 'first_name', at.at_first_name, 
    'last_name', at.at_last_name, 'date', at.at_date))
      filter (where at.id is not null), '[]') as authors
from books bk
left join author_to_book ba on bk.id = ba.book_id
left join authors at on at.id = ba.author_id
group by bk.id;
--3
create extension if not exists "uuid-ossp";
drop table if exists tasks, students, task_to_student cascade;

create table if not exists tasks(
  id uuid primary key default uuid_generate_v4(),
  name_task text,
  about text,
  complexity int
);

create table if not exists students(
  id uuid primary key default uuid_generate_v4(),
  nickname text,
  date_registrated date,
  rete int
);

create table task_to_student
(
    task_id uuid references tasks,
    student_id  uuid references students,
    primary key (task_id, student_id)
);

insert into tasks(name_task, about, complexity)
values ('task1', 'about1', 1),
    ('task2', 'task2', 2),
    ('task3', 'task3', 3);

insert into students(nickname, date_registrated, rete)
values ('nick1', '2022-02-23', 1),
    ('nick2', '2022-02-23', 2),
    ('nick3', '2022-02-23', 3);

insert into task_to_student(task_id, student_id)
values ((select id from tasks where complexity = 1),
    (select id from students where nickname = 'nick1')),
  ((select id from tasks where complexity = 1),
    (select id from students where nickname = 'nick2')),
  ((select id from tasks where complexity = 1),
    (select id from students where nickname = 'nick3')),
  ((select id from tasks where complexity = 2),
    (select id from students where nickname = 'nick1')),
  ((select id from tasks where complexity = 2),
    (select id from students where nickname = 'nick2'));


select 
  t.id,
  t.name_task,
  t.about,
  t.complexity,
  coalesce (json_agg(json_build_object(
  'id', st.id, 'nickname', st.nickname, 'date_registrated', st.date_registrated, 'rate', st.rete
  )) filter (where st.id is not null), '[]') as students
  from tasks t
  left join task_to_student tts on tts.task_id = t.id
  left join students st on tts.student_id = st.id
  group by t.id;
 
select 
  s.id,
  s.nickname,
  s.date_registrated,
  s.rete,
  coalesce (json_agg(json_build_object(
  'id', t.id, 'name_task', t.name_task, 'about', t.about, 'complexity', t.complexity
  )) filter (where t.id is not null), '[]') as tasks
  from students s
  left join task_to_student tts on tts.student_id = s.id
  left join tasks t on tts.task_id = t.id
  group by s.id
